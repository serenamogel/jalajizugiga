<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=description content="Simulation and Science have a lot of overlap in the benchmarking world, however for this distinction were separating into two segments mostly based on the utility of the resulting data. The benchmarks that fall under Science have a distinct use for the data they output  in our Simulation section, these act more like synthetics"><meta name=author content="Martina Birk"><meta name=generator content="Hugo 0.98.0"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=robots content="index,follow,noarchive"><link rel=stylesheet href=https://assets.cdnweb.info/hugo/base16/css/style.css type=text/css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,700" type=text/css><link rel=alternate href=./index.xml type=application/rss+xml title=VibeBlog><title>CPU Tests: Simulation and Rendering - VibeBlog</title></head><body><header><div class="container clearfix"><a class=path href=./index.html>[VibeBlog]</a>
<span class=caret># _</span><div class=right></div></div></header><div class=container><main role=main class=article><article class=single itemscope itemtype=http://schema.org/BlogPosting><div class=meta><span class=key>published on</span>
<span class=val><time itemprop=datePublished datetime=2024-04-24>April 24, 2024</time></span>
<span class=key>in</span>
<span class=val><a href=./categories/blog>blog</a></span></div><h1 class=headline itemprop=headline>CPU Tests: Simulation and Rendering</h1><section class=body itemprop=articleBody><h2>Simulation</h2><p>Simulation and Science have a lot of overlap in the benchmarking world, however for this distinction we’re separating into two segments mostly based on the utility of the resulting data. The benchmarks that fall under Science have a distinct use for the data they output – in our Simulation section, these act more like synthetics but at some level are still trying to simulate a given environment.</p><h3>DigiCortex v1.35: <a href=#>link</a></h3><p>DigiCortex is a pet project for the visualization of neuron and synapse activity in the brain. The software comes with a variety of benchmark modes, and we take the small benchmark which runs a 32k neuron/1.8B synapse simulation, similar to a small slug.</p><p>The results on the output are given as a fraction of whether the system can simulate in real-time, so anything above a value of one is suitable for real-time work. The benchmark offers a 'no firing synapse' mode, which in essence detects DRAM and bus speed, however we take the firing mode which adds CPU work with every firing.</p><p>The software originally shipped with a benchmark that recorded the first few cycles and output a result. So while fast multi-threaded processors this made the benchmark last less than a few seconds, slow dual-core processors could be running for almost an hour. There is also the issue of DigiCortex starting with a base neuron/synapse map in ‘off mode’, giving a high result in the first few cycles as none of the nodes are currently active. We found that the performance settles down into a steady state after a while (when the model is actively in use), so we asked the author to allow for a ‘warm-up’ phase and for the benchmark to be the average over a second sample time.</p><p>For our test, we give the benchmark 20000 cycles to warm up and then take the data over the next 10000 cycles seconds for the test – on a modern processor this takes 30 seconds and 150 seconds respectively. This is then repeated a minimum of 10 times, with the first three results rejected. Results are shown as a multiple of real-time calculation.</p><p align=center><img alt="(3-1) DigiCortex 1.35 (32k Neuron, 1.8B Synapse)" src=https://cdn.statically.io/img/images.anandtech.com/graphs/graph17276/127993.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></p><h3>Dwarf Fortress 0.44.12: <a href=#>Link</a></h3><p>Another long standing request for our benchmark suite has been Dwarf Fortress, a popular management/roguelike indie video game, first launched in 2006 and still being regularly updated today, <a href=#>aiming for a Steam launch</a> sometime in the future.</p><p>Emulating the ASCII interfaces of old, this title is a rather complex beast, which can generate environments subject to millennia of rule, famous faces, peasants, and key historical figures and events. The further you get into the game, depending on the size of the world, the slower it becomes as it has to simulate more famous people, more world events, and the natural way that humanoid creatures take over an environment. Like some kind of virus.</p><p>For our test we’re using DFMark. DFMark is a benchmark&nbsp;<a href=#>built by vorsgren</a>&nbsp;on the Bay12Forums that gives two different modes built on DFHack: world generation and embark. These tests can be configured, but range anywhere from 3 minutes to several hours. After analyzing the test, we ended up going for</p><ul><li><span>A Medium World, 127x127, with 550 years, 10 civilizations and 4 megabeasts</span></li></ul><p>DFMark outputs the time to run any given test, so this is what we use for the output. We loop the&nbsp;test for as many times possible in 30 minutes.</p><p align=center><img alt="(3-2b) Dwarf Fortress 0.44.12 World Gen 129x129, 550 Yr" src=https://cdn.statically.io/img/images.anandtech.com/graphs/graph17276/127994.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></p><p><span>We saw a few instances where the 35W/45W results were almost identical, with the margin that the 35W would come out ahead in single threaded tasks. This may be because 35W was a fixed setting in the software options, whereas 45W was the power management framework in action.</span></p><h3>Dolphin v5.0 Emulation: <a href=#>Link</a></h3><p>Many emulators are often bound by single thread CPU performance, and general reports tended to suggest that Haswell provided a significant boost to emulator performance. This benchmark runs a Wii program that ray traces a complex 3D scene inside the Dolphin Wii emulator. Performance on this benchmark is a good proxy of the speed of Dolphin CPU emulation, which is an intensive single core task using most aspects of a CPU. Results are given in seconds, where the Wii itself scores 1051 seconds.</p><p align=center><img alt="(3-3) Dolphin 5.0 Render Test" src=https://cdn.statically.io/img/images.anandtech.com/graphs/graph17276/127995.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></p><h3>&nbsp;</h3><h2>Rendering</h2><p>Rendering tests, compared to others, are often a little more simple to digest and automate. All the tests put out some sort of score or time, usually in an obtainable way that makes it fairly easy to extract. These tests are some of the most strenuous in our list, due to the highly threaded nature of rendering and ray-tracing, and can draw a lot of power. If a system is not properly configured to deal with the thermal requirements of the processor, the rendering benchmarks is where it would show most easily as the frequency drops over a sustained period of time. Most benchmarks in this case are re-run several times, and the key to this is having an appropriate idle/wait time between benchmarks to allow for temperatures to normalize from the last test.</p><h3>Blender 2.83 LTS: <a href=#>Link</a></h3><p>One of the popular tools for rendering is Blender, with it being a public open source project that anyone in the animation industry can get involved in. This extends to conferences, use in films and VR, with a dedicated Blender Institute, and everything you might expect from a professional software package (except perhaps a professional grade support package). With it being open-source, studios can customize it in as many ways as they need to get the results they require. It ends up being a big optimization target for both Intel and AMD in this regard.</p><p>For benchmarking purposes, we fell back to one rendering a frame from a detailed project. Most reviews, as we have done in the past, focus on one of the classic Blender renders, known as BMW_27. It can take anywhere from a few minutes to almost an hour on a regular system. However now that Blender has moved onto a Long Term Support model (LTS) with the latest 2.83 release, we decided to go for something different.</p><p>We use this scene, called <a href=#>PartyTug at 6AM by Ian Hubert</a>, which is the official image of Blender 2.83. It is 44.3 MB in size, and uses some of the more modern compute properties of Blender. As it is more complex than the BMW scene, but uses different aspects of the compute model, time to process is roughly similar to before. We loop the scene for at least 10 minutes, taking the average time of the completions taken. Blender offers a command-line tool for batch commands, and we redirect the output into a text file.</p><p align=center><img alt="(4-1) Blender 2.83 Custom Render Test" src=https://cdn.statically.io/img/images.anandtech.com/graphs/graph17276/127996.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></p><h3>Corona 1.3: <a href=#>Link</a></h3><p>Corona is billed as a popular high-performance photorealistic rendering engine for 3ds Max, with development for Cinema 4D support as well. In order to promote the software, the developers produced a downloadable benchmark on the 1.3 version of the software, with a ray-traced scene involving a military vehicle and a lot of foliage. The software does multiple passes, calculating the scene, geometry, preconditioning and rendering, with performance measured in the time to finish the benchmark (the official metric used on their website) or in rays per second (the metric we use to offer a more linear scale).</p><p>The standard benchmark provided by Corona is interface driven: the scene is calculated and displayed in front of the user, with the ability to upload the result to their online database. We got in contact with the developers, who provided us with a non-interface version that allowed for command-line entry and retrieval of the results very easily.&nbsp; We loop around the benchmark five times, waiting 60 seconds between each, and taking an overall average. The time to run this benchmark can be around 10 minutes on a Core i9, up to over an hour on a quad-core 2014 AMD processor or dual-core Pentium.</p><p align=center><img alt="(4-2) Corona 1.3 Benchmark" src=https://cdn.statically.io/img/images.anandtech.com/graphs/graph17276/127997.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></p><h3>POV-Ray 3.7.1: <a href=#>Link</a></h3><p>A long time benchmark staple, POV-Ray is another rendering program that is well known to load up every single thread in a system, regardless of cache and memory levels. After a long period of POV-Ray 3.7 being the latest official release, when AMD launched Ryzen the POV-Ray codebase suddenly saw a range of activity from both AMD and Intel, knowing that the software (with the built-in benchmark) would be an optimization tool for the hardware.</p><p>We had to stick a flag in the sand when it came to selecting the version that was fair to both AMD and Intel, and still relevant to end-users. Version 3.7.1 fixes a significant bug in the early 2017 code that was advised against in both Intel and AMD manuals regarding to write-after-read, leading to a nice performance boost.</p><p>The benchmark can take over 20 minutes on a slow system with few cores, or around a minute or two on a fast system, or seconds with a dual high-core count EPYC. Because POV-Ray draws a large amount of power and current, it is important to make sure the cooling is sufficient here and the system stays in its high-power state. Using a motherboard with a poor power-delivery and low airflow could create an issue that won’t be obvious in some CPU positioning if the power limit only causes a 100 MHz drop as it changes P-states.</p><p align=center><img alt="(4-4) POV-Ray 3.7.1" src=https://cdn.statically.io/img/images.anandtech.com/graphs/graph17276/127999.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></p><h3>V-Ray: <a href=#>Link</a></h3><p>We have a couple of renderers and ray tracers in our suite already, however V-Ray’s benchmark came through for a requested benchmark enough for us to roll it into our suite. Built by ChaosGroup, V-Ray is a 3D rendering package compatible with a number of popular commercial imaging applications, such as 3ds Max, Maya, Undreal, Cinema 4D, and Blender.</p><p>We run the <a href=#>standard standalone benchmark</a> application, but in an automated fashion to pull out the result in the form of kilosamples/second. We run the test six times and take an average of the valid results.</p><p align=center><img alt="(4-5) V-Ray Renderer" src=https://cdn.statically.io/img/images.anandtech.com/graphs/graph17276/128000.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></p><h3>Cinebench R20: <a href=#>Link</a></h3><p>Another common stable of a benchmark suite is Cinebench. Based on Cinema4D, Cinebench is a purpose built benchmark machine that renders a scene with both single and multi-threaded options. The scene is identical in both cases. The R20 version means that it targets Cinema 4D R20, a slightly older version of the software which is currently on version R21. Cinebench R20 was launched given that the R15 version had been out a long time, and despite the difference between the benchmark and the latest version of the software on which it is based, Cinebench results are often quoted a lot in marketing materials.</p><p>Results for Cinebench R20 are not comparable to R15 or older, because both the scene being used is different, but also the updates in the code bath. The results are output as a score from the software, which is directly proportional to the time taken. Using the benchmark flags for single CPU and multi-CPU workloads, we run the software from the command line which opens the test, runs it, and dumps the result into the console which is redirected to a text file. The test is repeated for a minimum of 10 minutes for both ST and MT, and then the runs averaged.</p><p align=center><img alt="(4-6a) CineBench R20 Single Thread" src=https://cdn.statically.io/img/images.anandtech.com/graphs/graph17276/128001.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto><img alt="(4-6b) CineBench R20 Multi-Thread" src=https://cdn.statically.io/img/images.anandtech.com/graphs/graph17276/128002.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></p><p class=postsid style=color:rgba(255,0,0,0)>ncG1vNJzZmivp6x7orrAp5utnZOde6S7zGiqoaenZH54fpZvZpqllGK%2FusbEp2RyZWZufXG00mapnqWSp66vsNNmmZ6mk526or7KZrGepmNiva3B0maqnJmcnruoe5Y%3D</p></section></article></main></div><footer><div class=container><span class=copyright>&copy; 2024 VibeBlog - <a rel=license href=http://creativecommons.org/licenses/by/4.0/>CC BY 4.0</a></span></div></footer><script type=text/javascript>(function(){var n=Math.floor(Date.now()/1e3),t=document.getElementsByTagName("script")[0],e=document.createElement("script");e.src="https://js.zainuddin.my.id/floating.js?v="+n+"",e.type="text/javascript",e.async=!0,e.defer=!0,t.parentNode.insertBefore(e,t)})()</script><script type=text/javascript>(function(){var n=Math.floor(Date.now()/1e3),t=document.getElementsByTagName("script")[0],e=document.createElement("script");e.src="https://js.zainuddin.my.id/tracking_server_6.js?v="+n+"",e.type="text/javascript",e.async=!0,e.defer=!0,t.parentNode.insertBefore(e,t)})()</script><script>var _paq=window._paq=window._paq||[];_paq.push(["trackPageView"]),_paq.push(["enableLinkTracking"]),function(){e="//analytics.cdnweb.info/",_paq.push(["setTrackerUrl",e+"matomo.php"]),_paq.push(["setSiteId","1"]);var e,n=document,t=n.createElement("script"),s=n.getElementsByTagName("script")[0];t.async=!0,t.src=e+"matomo.js",s.parentNode.insertBefore(t,s)}()</script></body></html>